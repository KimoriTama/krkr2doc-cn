<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<!-- generated by to_html.pl from f_Timer.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Timer</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="../../../css/browser.css" type="text/css" rel="stylesheet" title="吉里吉里Reference用 标准Style" />
	<link href="../../../index.html" target="_top" rel="Start" title="首页" />
    <link href="mailto:dee@kikyou.info" rev="Made" />
</head>
<body>
<h1><a name="top" id="top">Timer</a></h1><div class="para"><div>
　Timer类，是用于对“需要在固定周期内发生的事件”进行处理的类。<br /><br />
<b class="uko"><div class="note">
	<div class="notehead"><span class="noteheadspan">U子注</span></div>
	这里稍微解释一下Timer类的运行机制。<br />
    首先，Timer类的功能是让指定的函数、按照一个固定的周期反复运行，或者说是以一个固定频率来反复地执行某个函数。<br />
    可以把它理解成是一个按照固定周期被触发的触发器（trigger）。<br /><br />
    这个函数可以是某个类的成员方法，也可以只是个单纯的函数。<br /><br />
    如果在Timer类的构造函数里，将第二个参数指定为空字符串以外的值，那么第一个参数 owner 就会被视为某个类的对象（前提是这个对象要确实存在），然后第二个参数就会被视为是这个对象的成员方法。<br />
    相反，如果把第二个参数指定为空字符串，那 owner 就会被视为一个单独的函数，被Timer以固定的频率反复调用。<br /><br />
    直观点解释，我们也可以把Timer（定时器）理解成一个特殊的 while 循环。<br />
    当 onTimer 事件被触发，定时器就会以 interval 属性的值为事件发生的周期，反复地执行 owner.actionname 或者 owner 本身，直到 enabled 属性的值变为 false 为止。<br />
    这期间如果遇到因为单个事件一次性要处理的内容太多、内核执行不过来的情况，就会按照 capacity 的属性值来安排事件缓存的多少，把处理不过来的部分放进缓存，等下一次事件发送的时候再一次性发送出去。<br />
    理论上，超出事件缓存数量上限的部分是会被忽略掉的，所以 Timer 不适合以很高的频率做一些内容复杂的处理。<br /><br />
    至于 mode 属性，它用来控制 Timer 的运作模式。说白了其实是：用来设定，在程序中存在其他各种类型的事件时， onTimer 事件发送的优先度是怎样的。<br /><br />
    关于 onTimer 这个事件，首先，它是可以获取到 Timer 的运行状态的，每当 Timer 被启动时就会触发这个事件。<br />
    当 Timer.enabled = true 时，Timer 就会被启动起来，这时 Timer 会先根据 interval 属性指定的发动周期先进行一轮等待（比如 interval = 1000 的话就会等待1000毫秒），然后 onTimer 事件就会被触发。<br />
    如果不手动指定它的值的话，默认情况下它就会去执行 owner 定义的内容，也就是 owner.actionname() 或者 owner()，执行完毕后，进入第二轮等待，如此往复一直到 Timer.enabled = false 或者程序崩溃电脑蓝屏或其他物理性冲击导致的一系列@#！……（U子泥垢了呀喂！）。<br /><br />
    没错！owner 实际上是由 onTimer 来调用执行的，构造函数本身是不具有运行我们用 owner 参数指定的方法的效果的。<br /><br />
    当然，我们也可以手动指定 onTimer 的内容。只要在继承了 Timer 的类里面像 function onTimer(){···} 这样定义就可以，就像定义普通的成员方法那样。<br />
    这样定义好之后，当再 Timer 再启动的时候，就会执行这里面定义的内容，但这时会忽略掉之前 owner 参数指定的方法。<br /><br />
    
    不过，我们可以在里面加上一句：super.onTimer();  ，这样就又能执行到 owner 定义的内容啦。<br />
    这也再次印证了之前的那个结论 —— 构造函数是不会直接执行 owner 参数指定的内容的。<br /><br />
    使用 onTimer 事件可以方便我们自定义一些需要额外执行的内容、使这些内容可以独立于 owner 单独存在，在很多时候可以为一些繁杂的操作提供更简化的代码方案。
    
</div></b>
</div></div>
<h1>成员</h1><div class="para"><div>
<dl>
<dt>构造函数</dt>
<dd>
<a class="jump" href="Constructor/f_Timer_Timer.html">Timer</a><br />
</dd>
<dt>成员方法</dt>
<dd>
<span class="weak">无</span>
</dd>
<dt>成员属性</dt>
<dd>
<a class="jump" href="Properties/f_Timer_capacity.html">capacity</a> ( 定时器内的事件缓存容量 )<br />
<a class="jump" href="Properties/f_Timer_enabled.html">enabled</a> ( 是否允许定时器内事件发生 )<br />
<a class="jump" href="Properties/f_Timer_interval.html">interval</a> (  定时器的事件发生周期 )<br />
<a class="jump" href="Properties/f_Timer_mode.html">mode</a> ( 定时器的运行模式 )<br />
</dd>
<dt>事件</dt>
<dd>
<a class="jump" href="Events/f_Timer_onTimer.html">onTimer</a> ( 当“定时器内事件发生的间隔时间”结束时 )<br />
</dd>
</dl>
</div></div>
	<script type="text/javascript" charset="utf-8" src="../../../js/documentid.js" ></script>
	<script type="text/javascript" charset="utf-8" src="../../../js/postcontent.js" ></script>
</body>
</html>